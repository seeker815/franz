#!/usr/bin/env ruby
require 'json'
require 'thread'
require 'logger'

require 'slog'
require 'bunny'
require 'trollop'
require 'franz'


# Franz really only accepts a config file as an option, and that config file
# has got to conform to a certain format. If you're unsure, just look at the
# default options hashes in both Franz::Input and Franz::Output
parser = Trollop::Parser.new do
  version Franz::VERSION
  banner Franz::ART + "\n\n" + <<-EOS.gsub(/^    /, '')
    #{Franz::SUMMARY}

    Usage: franz [<options>]

    Options:
  EOS

  opt :config, 'Configuration file to use [FRANZ_CONFIG] (required)', \
    type: :string, required: !ENV['FRANZ_CONFIG'], default: ENV['FRANZ_CONFIG']

  opt :log, 'Log to file, not STDOUT [FRANZ_LOG] (optional)', \
    type: :string, required: false, default: ENV['FRANZ_LOG']

  opt :debug, 'Enable debugging output [FRANZ_DEBUG]', \
    default: !!ENV['FRANZ_DEBUG']
end

opts = Trollop.with_standard_exception_handling(parser) do
  parser.parse ARGV
end


Thread.abort_on_exception = true # Die quickly and with great ceremony

config = Franz::Config.new opts[:config]

# Set up Slog to send pretty, colored output to STDOUT, compact to FILE
level = :info
level = :debug if opts[:debug]
device = opts[:log] || $stdout
colorize, prettify = false, false
colorize, prettify = true, true if device.tty? rescue false
logger = Slog.new (config[:slog] || {}).merge \
  out: device,
  colorize: colorize,
  prettify: prettify,
  level: level

# In Franz, all queues are bounded
io_bound = config[:output][:bound] || 10_000
io = Queue.new
io = SizedQueue.new io_bound if io_bound > 0

logger.info \
  event: 'boot',
  version: Franz::VERSION

statz = Franz::Stats.new \
  interval: (config[:output][:stats_interval] || 300),
  logger: logger


# Now we'll connect to our output. This creates a new thread in the background,
# which will consume the events generated by our input on io
if config[:output][:rabbitmq]
  Franz::Output::RabbitMQ.new \
    input: io,
    output: config[:output][:rabbitmq],
    logger: logger,
    tags: config[:output][:tags],
    statz: statz

elsif config[:output][:kafka]
  Franz::Output::Kafka.new \
    input: io,
    output: config[:output][:kafka],
    logger: logger,
    tags: config[:output][:tags],
    statz: statz

elsif config[:output][:http]
  Franz::Output::HTTP.new \
    input: io,
    output: config[:output][:http],
    logger: logger,
    tags: config[:output][:tags],
    statz: statz

else
  Franz::Output::Device.new \
    input: io,
    logger: logger,
    output: config[:output][:device],
    tags: config[:output][:tags],
    statz: statz
end


# Franz has only one kind of input, plain text files.
Franz::Input.new \
  input: config[:input],
  output: io,
  logger: logger,
  checkpoint: config[:checkpoint],
  checkpoint_interval: config[:checkpoint_interval],
  statz: statz



# Ensure memory doesn't grow too large (> 1GB by default)
def mem_kb ; `ps -o rss= -p #{$$}`.strip.to_i ; end

mem_limit = config[:memory_limit] || 1_000_000
mem_sleep = config[:memory_limit_interval] || 60

statz.create :mem_kb
loop do
  sleep mem_sleep
  mem_used = mem_kb
  statz.set :mem_kb, mem_used
  if mem_used > mem_limit
    logger.fatal \
      event: 'killed',
      reason: 'Consuming too much memory',
      used: mem_used,
      limit: mem_limit
    exit(1)
  end
  logger.debug \
    event: 'memcheck',
    used: mem_used,
    limit: mem_limit
end