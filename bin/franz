#!/usr/bin/env ruby
require 'json'
require 'thread'
require 'logger'

require 'bunny'
require 'trollop'
require 'franz'


# If we find a local config, try to use it
# N.B. We'll fall back to the last guy listed here
config = nil
%w[
  config.json
  %{HOME}/.franz.json
  /etc/franz/franz.json
].each do |path|
  config = path % ENV rescue nil
  break if File.exist? config
end


# Franz really only accepts a config file as an option, and that config file
# has got to conform to a certain format. If you're unsure, just look at the
# default options hashes in both Franz::Input and Franz::Output
opts = Trollop::options(ARGV) do
  version Franz::VERSION
  banner Franz::ART + "\n\n" + <<-EOS.gsub(/^    /, '')
    #{Franz::SUMMARY}

    Usage: franz [<options>]

    Options:
  EOS
  opt :config, 'Configuration file to use', type: :string, default: config
  opt :debug,  'Enable debugging output', default: false
end

Thread.abort_on_exception = true # Die quickly and with great ceremony

config = Franz::Config.new opts[:config]
logger = Franz::Logger.new opts[:debug]

# The state file contains a Marshalled Hash with a compact representation of
# stateful inputs to various Franz streaming classes (e.g. the "known" option
# to Franz::Discover). This state file is generated automatically every time
# the program exits (see below) and loaded now, as the program begins.
state  = File.read(config[:state]) rescue nil
unless state.nil?
  state = Marshal.load state
  logger.info 'Loaded!'
end

begin
  io = Franz::Queue.new # N.B. This is a bounded queue

  # Now we'll connect to our output, RabbitMQ. This creates a new thread in the
  # background, which will consume the events generated by our input on io
  fout = Franz::Output.new \
    input: io,
    output: config[:output][:rabbitmq],
    logger: logger

  # Franz has only one kind of input, plain text files.
  fin = Franz::Input.new \
    input: config[:input],
    output: io,
    state: state,
    logger: logger

  # Remember, both the input and output were started up in background threads,
  # so we'll have to wait here in main or else we'll just exit.
  fout.join

rescue Interrupt
  # And here's where we generate the state file. We ask our input to stop
  # processing events and drain, which also happens to return a state Hash.
  logger.info 'Saving... '
  File.open(config[:state], 'w') do |f|
    f.write Marshal.dump(fin.stop)
  end
end