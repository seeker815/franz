#!/usr/bin/env ruby
require 'json'
require 'thread'
require 'logger'

require 'bunny'
require 'trollop'
require 'franz'


# If we find a local config, try to use it
# N.B. We'll fall back to the last guy listed here
config = nil
%w[
  config.json
  %{HOME}/.franz.json
  /etc/franz/franz.json
].each do |path|
  config = path % ENV rescue next
  break if File.exist? config
end


# Franz really only accepts a config file as an option, and that config file
# has got to conform to a certain format. If you're unsure, just look at the
# default options hashes in both Franz::Input and Franz::Output
opts = Trollop::options(ARGV) do
  version Franz::VERSION
  banner Franz::ART + "\n\n" + <<-EOS.gsub(/^    /, '')
    #{Franz::SUMMARY}

    Usage: franz [<options>]

    Options:
  EOS
  opt :config, 'Configuration file to use', type: :string, default: config
  opt :debug,  'Enable debugging output', default: false
end

Thread.abort_on_exception = true # Die quickly and with great ceremony

config = Franz::Config.new opts[:config]
logger = Franz::Logger.new opts[:debug]

begin
  io = Franz::Queue.new # N.B. This is a bounded queue

  # Now we'll connect to our output, RabbitMQ. This creates a new thread in the
  # background, which will consume the events generated by our input on io
  fout = Franz::Output.new \
    input: io,
    output: config[:output][:rabbitmq],
    logger: logger

  # Franz has only one kind of input, plain text files.
  fin = Franz::Input.new \
    input: config[:input],
    output: io,
    logger: logger,
    checkpoint: config[:checkpoint],
    checkpoint_interval: config[:checkpoint_interval]

  # Remember, both the input and output were started up in background threads,
  # so we'll have to wait here in main or else we'll just exit.
  fout.join

rescue SignalException => e
  logger.fatal e.inspect
rescue SystemExit, Interrupt => e
  logger.fatal e.inspect
ensure
  fin.stop
  fin.checkpoint
end